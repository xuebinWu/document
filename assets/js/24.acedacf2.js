(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{206:function(a,r,e){"use strict";e.r(r);var t=e(0),i=Object(t.a)({},function(){var a=this,r=a.$createElement,e=a._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"hybrid"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hybrid","aria-hidden":"true"}},[a._v("#")]),a._v(" Hybrid")]),a._v(" "),e("div",{staticClass:"warning custom-block"},[e("p",[a._v("除了apiready方法外，任何一个hybrid方法，都必须等api注入后，方可调用。如果遇到hybrid方法不生效的情况，请检查调用时机是否正确。")])]),a._v(" "),e("h3",{attrs:{id:"门户打开页面显示白屏-骨架屏，没有出具体页面"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#门户打开页面显示白屏-骨架屏，没有出具体页面","aria-hidden":"true"}},[a._v("#")]),a._v(" 门户打开页面显示白屏/骨架屏，没有出具体页面")]),a._v(" "),e("ul",[e("li",[a._v("检查permission.js中的路由守卫是否执行了next()方法，有可能是守卫中的接口请求出错，导致next()方法没有执行。")]),a._v(" "),e("li",[a._v("检查main.js中有没有执行.$mount('#app')挂载操作。main.js中禁止出现立即执行api的代码。")])]),a._v(" "),e("h3",{attrs:{id:"输入文字后点击跳转页面，软键盘收起位置会出现黑色色块"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#输入文字后点击跳转页面，软键盘收起位置会出现黑色色块","aria-hidden":"true"}},[a._v("#")]),a._v(" 输入文字后点击跳转页面，软键盘收起位置会出现黑色色块")]),a._v(" "),e("p",[a._v("在输入文字后，触发跳转前，设置一个200ms的延时。让键盘收起之后再进行跳转操作。")]),a._v(" "),e("h3",{attrs:{id:"进入模块后，没有出现模块首页，显示报错页面"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#进入模块后，没有出现模块首页，显示报错页面","aria-hidden":"true"}},[a._v("#")]),a._v(" 进入模块后，没有出现模块首页，显示报错页面")]),a._v(" "),e("p",[a._v("每回打开一个新的模块，openFrame/openWin方法都会给原生发送一个’startLoadFrame‘消息；在apiready方法被调用后，会给原生发送一个’endLoadFrame‘消息；如果，原生在接收到’startLoadFrame‘消息之后15秒内，没有收到’endLoadFrame‘消息，就会弹出报错页面。所以开发者要检查web端为什么没有触发apiready方法。")]),a._v(" "),e("h3",{attrs:{id:"没有触发apiready方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#没有触发apiready方法","aria-hidden":"true"}},[a._v("#")]),a._v(" 没有触发apiready方法")]),a._v(" "),e("p",[a._v("一般存在这几种情况，会导致main.js文件中的apiready方法不被触发。")]),a._v(" "),e("ul",[e("li",[a._v("在其他文件中，也定义了apiready方法；")]),a._v(" "),e("li",[a._v("apiready方法只能在 process.env.NODE_ENV === 'production' 条件下才会被触发，打包时条件弄混了；")]),a._v(" "),e("li",[a._v("在触发apiready方法前，出现了立即执行api方法的代码，导致js报错。")])]),a._v(" "),e("h3",{attrs:{id:"模块首页中，-h-hybrid方法不生效"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模块首页中，-h-hybrid方法不生效","aria-hidden":"true"}},[a._v("#")]),a._v(" 模块首页中，$h/hybrid方法不生效")]),a._v(" "),e("p",[a._v("可以在this.$nextTick中，进行方法的调用")]),a._v(" "),e("h3",{attrs:{id:"在hybrid情况下第一次进入页面没有走router-beforeeach函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在hybrid情况下第一次进入页面没有走router-beforeeach函数","aria-hidden":"true"}},[a._v("#")]),a._v(" 在hybrid情况下第一次进入页面没有走router.beforeEach函数")]),a._v(" "),e("p",[a._v("排查发现，当permission在api.ready函数中注入时,写的函数push到beforeEach 函数队列的时，第一个页面渲染时已经调用过一次beforeEach（此时为空的函数队列）。解决办法将 导入提前到router注入到vue实例之前。")])])},[],!1,null,null,null);r.default=i.exports}}]);